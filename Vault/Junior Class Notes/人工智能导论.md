## 2 Agent
### Outline
1. agent的本质
2. agent是否完美
3. 环境的多样性
4. 带来的各种agent分类
---
> **agent is an entity that perceives and acts**
> agent是一个能感知并行动的实体
- 通过传感器感知环境，并通过执行器对该环境产生作用
- 软件Agent
- 从数学角度：Agent函数描述了Agent的行为

### 理性 Rational
> **Maxmize Your Expected Utility**
> 使得期望性能最大化

**任务环境的规范描述**
PEAS
性能 环境 执行器 传感器

环境：
完全可观察和部分可观察      单Agent和多Agent
确定的和随机的		片段式和延续性的
静态的与动态的		离散的与连续的
已知的与未知的

> Agent = 体系结构+程序

- **Agent程序**
	- 简单反射——*条件行为规则*
	- 基于模型的反射agent
	根据感知和对世界的知识来做决策
	世界状态基于感知输入被更新
	触发规则
	智能来自于：储存的关于世界的知识+coder
	- 基于目标的agent——*搜索 规划*
	- 基于效用的agent——*效用函数的量化*
	- 基于学习的agent

+	- 基于学习的agent

## 3 通过搜索进行问题求解
> 无信息搜索算法
> 是指算法除了问题定义本身没有任何其他信息。
- 无信息搜索
	- 深度优先搜索
	- 广度优先搜索
- 有信息搜索

### 问题求解Agent
Agent能采纳一个目标
**搜索问题的表示——状态空间表示法**
状态：agent和他的环境的一个配置
状态空间图：有向图
初始状态 行为 转移模型 目标测试——返回路径（行为序列）

- 目标测试：有时目标状态是一个显式集合
- 路径耗散：为每个路径赋一个耗散值，即边加权
- 问题的解：从初始状态目标状态的一组行动序列。所有解里路径耗散最小的解是最优解。

搜索算法输入的是问题 输出的是问题的解
一旦找到解，agent进入执行阶段

状态 初始状态 后继状态 目标测试 路径耗散
> 搜索算法：一个解就是一个行动序列，搜索算法的工作就是考虑各种可能的行动序列。

> 搜索算法主要的区别是如何选择将要扩展的状态。

### 无信息搜索策略（盲目搜索）
按搜索策略的不同分类：
如果搜索中有闭环就只能使用图搜索

#### 广度优先搜索
利用FIFO队列实现
总是先扩展frontier表中最浅的节点
frontier是一个队列结构（先进先出）
#### 一致代价搜索
当每一步的行动代价都相等时广度优先搜索是最优的。
扩展的是路径耗散最小的节点
#### 深度优先搜索
利用LIFO栈实现
总是首先扩展frontier表中最深的节点
frontier是一个栈结构（后进先出）
#### 深度受限搜索
避免在无限状态空间应用深度优先搜索出现问题
#### 迭代加深的深度优先搜索

#### SearchTree 搜索树
搜索树是由初始状态和后继函数共同产生的，同时也定义了状态空间
> 在边缘中选择节点并扩展的过程一直继续，直到找到了解或者已经没有状态可扩展

#### Graph Search 图搜索算法
搜索算法要做的是：生成后继并区分目标状态和非目标状态
搜索策略以节点扩展的次序来分类

**迭代加深的深度优先搜索**
**代价敏感搜索算法**
**一致代价搜索法**——DjiKstra算法


### 有信息搜索算法 启发式搜索
- 利用启发函数
  
#### 贪婪最佳优先搜索——变形的深度优先搜索算法
- 试图扩展离目标最近的节点 
- 找到的并不是最优解

#### A*搜索
综合了一致代价搜索和贪婪搜索
- 利用每一步的计数步数来计算**路径代价**

保证最优的条件
- 可采纳性
  - 永远不会超过经过节点n的实际代价
- 一致性：
  - 一致性代价高于可采纳性代价 但一般满足可采纳性的都满足一致性条件

### 启发式函数
> 利用8数码问题研究启发式的一般性质

- 两种启发函数计算：
> 计算不在目标状态的节点数量和
> 曼哈顿距离：水平和竖直的距离和

**有信息搜索——占优**
占优的启发函数对搜索更好
即：典型的搜索代价（所展开的节点平均数量）要比起另一个更好
> 不同的启发函数对算法的性能影响巨大

### 如何设计启发函数
  - 根据当前的约束条件
  - 根据松弛约束条件出发设计可采纳的启发式


## 4 超越经典搜索
> 有些路径不重要，目标状态本身更重要。目标状态本身就是解
任务通常是寻找某个函数的额极大或极小值

### 局部搜索算法和最优化问题
状态空间地形图

![一位状态空间地形图 找到局部极值](http://blogstorage.cyang.site/AI_class/c4/climb_hill-1)

#### 爬山法——局部贪婪算法
- 即：通过循环不断寻找当前状态的相邻状态的极值
- 局部爬山法可以找到全局极大值
由于是随记设定的起始位置，不同的起始位置找到的全局极大值都不同

e.g. 医院配置问题

- 特例：平台（山肩） 相邻点代价相等的平台

##### Varients变形：（以寻找极大值为例）
- 最陡上升法：选择最大的邻居
- 随机方法：从高值的邻居中随机选择
- 随机重启：实施爬山多次
- 局部束搜索：选择k个最高值的邻居

#### 模拟退火算法
- 利用梯度下降的思路
- 增加温度参数 增加了找到最优解的概率。能更大程度避免陷入局部最优。
根据当前状态不同的温度 以不同的概率来接受下一个邻居

前半部分是更大能量的随机寻找最优解
后半部分是类似于爬山算法的寻找局部最优解

#### 连续空间的局部搜索

### 遗传算法🧬
> 遗传算法( genetic algorithm,或GA)是随机東搜索的一个变形,它通过把两个父状态结合来生成后继,而不是通过修改单一状态进行。这和随机剪枝搜索一样,与自然选择类似,除了我们现在处理的是有性繁殖而不是无性繁殖。

**一般框架：**
- 种群：从k个随机生成的状态开始
- 适应度函数：每个状态由其目标函数给出适应度评估值
- 杂交点：在字符串中随机选取一个位置
- 变异：每个位置都会按照小的独立概率变异

> 通常的情况是早期的种群是多样化的,因此杂交(类似于模拟退火)在搜索过程的早期阶段在状态空间中采用较大的步调,而在后来当大多数个体都很相似的时候采用较小的步调

像随机東束搜索一样,遗传算法结合了上山趋势、随机探索和在并行搜索线程之间交换信息。遗传算法最主要的优点,如果算是,来自于杂交操作。然而可以在数学上证明,如果基因编码的位置在初始的时候就允许随机转换,杂交就没有优势了。直观上说,杂交的优势在于它能够将独立发展出来的能执行有用功能的字符区域结合起来,因此提高了搜索的粒度。

个体选择策略
- 轮盘赌法
适应度更高的被选中的概率就更高
- 锦标赛法

交叉率
变异率

### 连续空间中的局部搜索——梯度上升/下降


